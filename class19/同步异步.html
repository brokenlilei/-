<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <script>
        /*
           JS是单线程的，自设计以来就是从上往下解读代码（同一时间只能做一件事）

           事件调用  ---> 把任务交给了事件引擎（所有的JS事件全部都是异步的）

           同步：
               代码从上到下一次执行，如果一个地方卡住了，下面的代码就都会被阻塞

           异步：
               虽然会从上往下依次执行，如果一个地方卡住了，是不会阻塞下面的代码向下运行的。
               异步常用于定时器、所有的事件（函数）、promise



           同步和异步的运行流程：
               JS先执行主线程的代码，如果主线程有异步代码，比如定时器或者promise等事件时，
               会把异步代码放入到异步队列中存储，当异步代码的条件成立时，就会把异步代码传入
               至主线程中执行。异步队列中又分为宏任务和微任务，其优先级是微任务大于宏任务的
               优先级，换句话说，有微任务的话，优先执行微任务，再执行宏任务。当主线程有空间执行
               传入的代码时，异步队列会把代码传入到主线程中进行解析，这个过程也被叫做事件循环。

               *****注意*****
               假如在主线程执行过程中，宏任务中在开一个微任务，那么先执行宏任务，
               再执行被宏任务中的微任务


               setTimeout(function(){
                   promise()
               });


               当然，异步也有它的缺点就是不容进行后期的维护开发，只有同步操作才有利于维护
               。原因就是上面的代码执行完才会执行下面的。

        */


        // let a = 10;
          
        // setTimeout(()=>{
        //     a = 20;
        // },0);

        // cosnole.lgo(a);


        // document.click = function(){
        //     comnsole.log(a);
        // }   


        // setTimeout(() =>{
        //     console.log(a,'2秒');
        // },2000);


        // setTimeout(() => {
        //     console.log(a,'定时器');
        // });

        // let p = new Promise((rej,res) =>{
        //     reg(5);
        // });
        // p.then((d)=>{
        //     cosnole.log(d,'promise');
        // });


         // a = 20;
         // console.log(a);

        (function a(){
            a = 20;
            console.log(a);
        })();
    </script>
</body>
</html>