<<<<<<< HEAD
###  this（小难点）
     -掌握this什么情况下到底是什么
         1，在事件中，事件触发是谁，this就是谁
         2，函数直接调用，默认this为window
     ```
         document.onclick = fn();
         function fn(){
             console.log(this);  //默认为window
         } 
      ```

         3,方法（函数前有主的都叫方法），this就是 . 前面的主（箭头函数例外）

      - 箭头函数，它的this为函数定义时的上下文作用域
      ```
         document.onclick = function(){
             let fn => ()=>{
                 console.log(this);
             }
             fn();
         }
       ```

 ###    单例模式
      -单独是实例（实例，具体的实物）
      ```
          let obj = {
              name:'董尚',
              age:12,
              sex:'男',
              shuai:true,
          }      
      ```

    -高级单例模式（让内部代码隐藏，形成模块化编程）
    ```
       let obj = {
              name:'董尚',
              age:12,
              sex:'男',
              shuai:true,
          }       
    ```

    -工厂模式（有初始化，加工，出厂）
       目的是批量生产对象     
     ```
         function person(name,age,job,sex){
             let obj = new Object();//初始化（原材料）

             //加工
             obj.name = name;
             obj.age = age;
             obj.job = job;
             obj.sex = sex;

             //出厂
             return obj；
         }  

         //obj和obj2就叫做实例

         let obj = person（'赵炎',15,'前端开发工程师','?');//批量生产
         let obj2 = person（'你真胖',15,'前端开发工程师','?');

    ````     

 ### 面向对象
      - new
       一元运算符，专门运算** 函数 ** 的，能让函数不加括号的情况下执行
       而加括号是为了传参
       1.构造函数中的this就是这个构造函数中的*实例化对象*，默认的this也是
       2.return 返回值如果是简单类型，那么返回结果为实例化对象；
                如果返回值为引用类型，那么返回结果就是这个引用类型。


  ```
     原型题：
       function Fn(){
        this.a = 10;
    }
    Fn.prototype.a = 20;
    Fn.a = 30;
    Function.prototype.a = 50;
    let f = new Fn();
    f.a = 40;

    console.log(f.a);
    // console.log(Fn.prototype.a)

    // Fn()
    // console.log(window.a);

    // console.log(Fn.a);      

 ```   
=======
### 作用域
    -指的是JS运行的范围

    -作用域分为两种，一种是全局作用域，另一种叫做局部作用域

- 全局作用域：
```
  当浏览器打开解读到script标签的时候，会把JS运行在一个window的全局作用域下，
  全局会生成一个全局的活动变量对象，会把所有的变量或者函数设置为这个对象下属性，
整个window下的环境都被叫做全局作用域。所以一个变量或者一个函数，默认属于window。


   console.log(window.a);//如果没有使用var声明变量，在复制之前是不会把a挂在window上的，所以a是找不到的
    a = 10;
    console.log(window);//赋值之后window下就有a
```

- 全局作用域：
```
    在运行函数时，函数内部会开辟一个执行栈，在执行栈钟会创建一个活动变量的对象，会把函数中所有变量，函数存储到这个活动变量下，
    执行栈去运行这个活动变量，这些活动变量下的变量，函数***只会作用在函数内***，
    这种现象就叫做局部作用域。

 作用域链：
      如果函数内访问不到某个变量，先去参数中找，还找不到就去父级函数内找，直到window全局，还找不到就直接报错

     - 局部作用域运行机制：
        1.没有形参时，但有var，如果在var的上方访问这个变量，结果是undefined

        2.有形参并且也有实参也有var时，如果在var的上方访问不到这个变量，结果应该是实参

        3.如果函数内有函数，有形参也有实参，那么结果就是函数内的函数。

 ```       
- 变量提升(预解析机制)：
          当浏览器去解析代码时，会提前解析全局的变量和函数的过程。

      解读代码时一定要记住以下两个步骤：
      第一步：
          上来就直接找var和function声明

      第二步：
          逐步解读代码，此时var和function声明就不用了再去读了，
          一般读的就是赋值（=），计算，输出，判断···

    PK规则：变量没有函数大，后面的函数声明比前面的函数声明大（后面的函数声明会覆盖前面的函数声明）

       ```
          /*
             一个匿名函数自执行函数，如果带有名字，在函数体内不管如何赋值同名变量，结果都等于这个
             有名函数。
          */           
          var a = 10;
          (function a(){
              a = {};
              console.log(a);//还是a函数代码块
          })();

      ```

###  var,let与const的区别
  ```
      var 变量
          变量提升，存入到全局的活动对象中，允许有多个同名变量，
          不支持块级作用域

      let 变量
           不会变量提升且有暂存死区（在变量定义的上方都访问不到这个变量）
           不会存入到全局的活动变量对象中
           不允许有多个同名的变量
           支持块级作用域

      const 常量
         不会变量提升且有暂存死区（在变量定义的上方都访问不到这个变量）
         不会存入到全局的活动变量对象中
         不允许有多个同名变量
         值是可以被改变的（引用类型可以改变属性值）
         声明了必须要赋值

   ```

   块级作用域：
      {
          console.log(a);//在上方访问块中的函数a，结果undefined
          if(a){
              console.log(1)
          }else{
              console.log(2)
          }
          {
              //这个函数在块中，在预解析的时候会undefined
              function a(){}
          }
          console.log(a)
      }                               
>>>>>>> 4d9bcaabb990174dc28e0ce8f508c478650b2a9a
