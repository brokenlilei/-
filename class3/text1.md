### 作用域
    -指的是JS运行的范围

    -作用域分为两种，一种是全局作用域，另一种叫做局部作用域

- 全局作用域：
```
  当浏览器打开解读到script标签的时候，会把JS运行在一个window的全局作用域下，
  全局会生成一个全局的活动变量对象，会把所有的变量或者函数设置为这个对象下属性，
整个window下的环境都被叫做全局作用域。所以一个变量或者一个函数，默认属于window。


   console.log(window.a);//如果没有使用var声明变量，在复制之前是不会把a挂在window上的，所以a是找不到的
    a = 10;
    console.log(window);//赋值之后window下就有a
```

- 全局作用域：
```
    在运行函数时，函数内部会开辟一个执行栈，在执行栈钟会创建一个活动变量的对象，会把函数中所有变量，函数存储到这个活动变量下，
    执行栈去运行这个活动变量，这些活动变量下的变量，函数***只会作用在函数内***，
    这种现象就叫做局部作用域。

 作用域链：
      如果函数内访问不到某个变量，先去参数中找，还找不到就去父级函数内找，直到window全局，还找不到就直接报错

     - 局部作用域运行机制：
        1.没有形参时，但有var，如果在var的上方访问这个变量，结果是undefined

        2.有形参并且也有实参也有var时，如果在var的上方访问不到这个变量，结果应该是实参

        3.如果函数内有函数，有形参也有实参，那么结果就是函数内的函数。

 ```       
- 变量提升(预解析机制)：
          当浏览器去解析代码时，会提前解析全局的变量和函数的过程。

      解读代码时一定要记住以下两个步骤：
      第一步：
          上来就直接找var和function声明

      第二步：
          逐步解读代码，此时var和function声明就不用了再去读了，
          一般读的就是赋值（=），计算，输出，判断···

    PK规则：变量没有函数大，后面的函数声明比前面的函数声明大（后面的函数声明会覆盖前面的函数声明）

       ```
          /*
             一个匿名函数自执行函数，如果带有名字，在函数体内不管如何赋值同名变量，结果都等于这个
             有名函数。
          */           
          var a = 10;
          (function a(){
              a = {};
              console.log(a);//还是a函数代码块
          })();

      ```

###  var,let与const的区别
  ```
      var 变量
          变量提升，存入到全局的活动对象中，允许有多个同名变量，
          不支持块级作用域

      let 变量
           不会变量提升且有暂存死区（在变量定义的上方都访问不到这个变量）
           不会存入到全局的活动变量对象中
           不允许有多个同名的变量
           支持块级作用域

      const 常量
         不会变量提升且有暂存死区（在变量定义的上方都访问不到这个变量）
         不会存入到全局的活动变量对象中
         不允许有多个同名变量
         值是可以被改变的（引用类型可以改变属性值）
         声明了必须要赋值

   ```

   块级作用域：
      {
          console.log(a);//在上方访问块中的函数a，结果undefined
          if(a){
              console.log(1)
          }else{
              console.log(2)
          }
          {
              //这个函数在块中，在预解析的时候会undefined
              function a(){}
          }
          console.log(a)
      }                               
