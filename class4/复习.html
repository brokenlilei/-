<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
   <script>
    /*
    this: 
        window(单纯的函数调用)
        事件对象：事件函数中的this，事件触发的时候
        主：this就是 . 前面的引用类型
        箭头函数：跟着函数创建时的上下文作用域


     单例模式，高级单例模式，实例身上集合了各种属性和方法
      
     (function (){
         return {}
     })()


     工厂模式（为了批量生成对象，其中有初始化，加工，出厂）

     面向对象：(特征为封装，继承，多态；核心是谁来做)
           把具有相同特征的代码抽离出来归为一类，
           再把描述这个类的公共属性或方法挂在这一类的原型下的一种编程思想

     原型与原型链的关系：


     什么是原型： 
         函数下的一个属性prototype，值为对象。
         作用：
            构造函数原型下的属性或方法，只能给这个构造函数下的实例使用

     什么是原型链：
           _proto_ , 每个实例上都有一个_proto_ 属性
           作用：
              实例上的原型链  ===  构造函数的原型




    document.onclick = function(){
        console.log(this);
        let f = ()=> {
            console.log(this);
        }
        f();
    }

    fn();
    function(){
        fn();
    }

    
    function fn(){
        console.log(this);
    }
           
     let obj = {
         fn:{
             func:{
                 fn:fn
             }
         }
     }      
     obj.fn.fnc.fn();




        ******
        实例下如果有，优先实例下的属性或者方法;

        如果没有，就通过实例下的原型链找到构造函数的原型，
        
        构造函数的原型的原型链找到Object的原型，直到找到window，找不到的话

        就为undefined。

        Function的原型链等于Function的原型

       *******


       通过实例调用构造函数原型下的方法或者属性，this就是实例

       函数的引用类型就是一个特殊的实例化对象

        new Function -> function (){}
    */




    function Fn(){
        //this.a = 10;
    }
    Fn.prototype.a = 20;
    //Fn.a = 30;
    Fn.prototype.a = 40;
    Object.prototype.a = 60;
    Function.prototype.a = 50;
    //Function.a = 70;
    let f = new Fn();

    //f.a = 40;
    console.log(Fn._proto_.prototype._proto_.a);
    //Fn._proto_-> Function.prototype.prototype
    //console.log(f._proto_._proto_.a);//60
    //Fn.prototype._proto_->Object.prototype.a
    //console.log(f._proto_.prototype.a);
    // console.log(Object.a);//Object.a -> Function.prototype
    // console.log(Fn.__proto__.__proto__.a); //60
    //Function.prototype.__proto__ -> Object.prototype

    </script>
</body>
</html>