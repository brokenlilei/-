###  this（小难点）
     -掌握this什么情况下到底是什么
         1，在事件中，事件触发是谁，this就是谁
         2，函数直接调用，默认this为window
     ```
         document.onclick = fn();
         function fn(){
             console.log(this);  //默认为window
         } 
      ```

         3,方法（函数前有主的都叫方法），this就是 . 前面的主（箭头函数例外）

      - 箭头函数，它的this为函数定义时的上下文作用域
      ```
         document.onclick = function(){
             let fn => ()=>{
                 console.log(this);
             }
             fn();
         }
       ```

 ###    单例模式
      -单独是实例（实例，具体的实物）
      ```
          let obj = {
              name:'董尚',
              age:12,
              sex:'男',
              shuai:true,
          }      
      ```

    -高级单例模式（让内部代码隐藏，形成模块化编程）
    ```
       let obj = {
              name:'董尚',
              age:12,
              sex:'男',
              shuai:true,
          }       
    ```

    -工厂模式（有初始化，加工，出厂）
       目的是批量生产对象     
     ```
         function person(name,age,job,sex){
             let obj = new Object();//初始化（原材料）

             //加工
             obj.name = name;
             obj.age = age;
             obj.job = job;
             obj.sex = sex;

             //出厂
             return obj；
         }  

         //obj和obj2就叫做实例

         let obj = person（'赵炎',15,'前端开发工程师','?');//批量生产
         let obj2 = person（'你真胖',15,'前端开发工程师','?');

    ````     

 ### 面向对象
      - new
       一元运算符，专门运算** 函数 ** 的，能让函数不加括号的情况下执行
       而加括号是为了传参
       1.构造函数中的this就是这个构造函数中的*实例化对象*，默认的this也是
       2.return 返回值如果是简单类型，那么返回结果为实例化对象；
                如果返回值为引用类型，那么返回结果就是这个引用类型。


  ```
     原型题：
       function Fn(){
        this.a = 10;
    }
    Fn.prototype.a = 20;
    Fn.a = 30;
    Function.prototype.a = 50;
    let f = new Fn();
    f.a = 40;

    console.log(f.a);
    // console.log(Fn.prototype.a)

    // Fn()
    // console.log(window.a);

    // console.log(Fn.a);      

 ```   